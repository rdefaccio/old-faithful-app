# Normalize again defensively
combos <- unique(gsub("\\s+", " ", trimws(combos)))
# Define palette: gray for 'None', distinct for others
non_none <- setdiff(combos, "None")
k <- length(non_none)
color_vec <- if (k > 0) {
base_cols <- if (k <= 12) RColorBrewer::brewer.pal(max(3, min(12, k)), 'Set3')[seq_len(k)] else grDevices::rainbow(k)
c('None' = '#f0f0f0', stats::setNames(base_cols, non_none))
} else {
c('None' = '#f0f0f0')
}
# Preserve ordering in legend
color_vec <- color_vec[unique(c('None', setdiff(combos, 'None')))]
p <- plot_ly()
# Static (no frame) traces for legend (single year snapshot)
if (nrow(md) > 0) {
base_year <- suppressWarnings(min(md$Year, na.rm = TRUE))
base_md <- md[md$Year == base_year, , drop = FALSE]
for (combo in combos) {
dfc <- base_md[base_md$ComboIndicators == combo, , drop = FALSE]
if (nrow(dfc) == 0) next
col <- if (!is.null(color_vec[combo])) color_vec[combo] else '#cccccc'
cs <- list(list(0, col), list(1, col))
p <- add_trace(
p,
data = dfc,
type = 'choropleth',
locations = ~locations,
locationmode = 'USA-states',
z = I(rep(1, nrow(dfc))),
zmin = 0, zmax = 1,
colorscale = cs,
showscale = FALSE,
text = ~tooltip,
hoverinfo = 'text',
name = combo,
legendgroup = combo,
showlegend = TRUE,
marker = list(line = list(color = 'white', width = 0.5)),
hoverlabel = list(align = 'left')
)
}
# Animated traces (one per combo including all years) with legend hidden
multi_year <- length(unique(md$Year)) > 1
if (multi_year) {
for (combo in combos) {
dfc_all <- md[md$ComboIndicators == combo, , drop = FALSE]
if (nrow(dfc_all) == 0) next
col <- if (!is.null(color_vec[combo])) color_vec[combo] else '#cccccc'
cs <- list(list(0, col), list(1, col))
p <- add_trace(
p,
data = dfc_all,
type = 'choropleth',
locations = ~locations,
locationmode = 'USA-states',
frame = ~Year,
z = I(rep(1, nrow(dfc_all))),
zmin = 0, zmax = 1,
colorscale = cs,
showscale = FALSE,
text = ~tooltip,
hoverinfo = 'text',
name = combo,
legendgroup = combo,
showlegend = FALSE,
marker = list(line = list(color = 'white', width = 0.5)),
hoverlabel = list(align = 'left')
)
}
}
}
p %>%
layout(
geo = list(scope = 'usa', projection = list(type = 'albers usa'), showland = TRUE,
landcolor = toRGB('gray95'), subunitcolor = toRGB('gray85'), countrycolor = toRGB('gray85'),
lakecolor = toRGB('white'), showsubunits = TRUE, showcountries = TRUE),
margin = list(l = 0, r = 0, t = 0, b = 0),
showlegend = TRUE
) %>%
animation_opts(frame = 800, transition = 200, easing = "linear", redraw = FALSE) %>%
animation_slider(currentvalue = list(prefix = "Year: "))
}
#' Convenience function: build map directly from data + inputs
#' @param data raw data
#' @param inputs list with topic_select, indicator_select
#' @return plotly object
build_map_from_inputs <- function(data, inputs) {
md <- map_data_fn(data, inputs)
build_map_plot(md)
}
build_map_from_inputs(data, inputs)
#' Build map data (includes combination columns, tooltip, codes)
#' @param data raw data
#' @param inputs list of selections
map_data_fn <- function(data, inputs) {
df_filt <- filtered_data_fn(data, inputs)
detail <- citation_detail_fn(df_filt)
state_ref <- tibble::tibble(State = state.name, locations = state.abb)
year_vec <- if ("Year" %in% names(data) && any(!is.na(data$Year))) {
seq.int(min(data$Year, na.rm = TRUE), max(data$Year, na.rm = TRUE))
} else { 2000:2020 }
full_grid <- tidyr::expand_grid(State = state_ref$State, Year = year_vec)
counts <- detail %>%
dplyr::group_by(State, Year) %>%
dplyr::summarise(Count = sum(CountIndicator), .groups = "drop")
lines <- detail %>%
dplyr::mutate(line = paste0(
"<b>",
htmltools::htmlEscape(Indicator),
"</b><br>",
htmltools::htmlEscape(CitationText)
)
) %>%
dplyr::group_by(State, Year) %>%
dplyr::summarise(lines = paste(line, collapse = "<br>"), .groups = "drop")
combos <- detail %>%
dplyr::group_by(State, Year) %>%
dplyr::summarise(
ComboIndicators = paste(sort(unique(Indicator)), collapse = " + "),
.groups = "drop"
)
tooltip_df <- full_grid %>%
dplyr::left_join(counts, by = c("State","Year")) %>%
dplyr::left_join(lines, by = c("State","Year")) %>%
dplyr::left_join(combos, by = c("State","Year")) %>%
dplyr::left_join(state_ref, by = "State") %>%
dplyr::mutate(
Count = dplyr::coalesce(Count, 0L),
ComboIndicators = dplyr::coalesce(ComboIndicators, "None"),
ComboIndicators = gsub("\\s+", " ", trimws(ComboIndicators)),
HasCitation = as.integer(Count > 0L),
tooltip = ifelse(is.na(lines) | lines == "",
paste0(State, " - ", Year, "<br><i>No citations</i>"),
paste0(State, " - ", Year, "<br>", lines))
)
combo_levels <- sort(unique(tooltip_df$ComboIndicators))
combo_levels <- c(setdiff("None", combo_levels), setdiff(combo_levels, "None"))
tooltip_df <- tooltip_df %>%
dplyr::mutate(
ComboIndicators = factor(ComboIndicators, levels = combo_levels),
ComboCode = as.integer(ComboIndicators) - 1L) %>%
dplyr::filter(!is.na(locations))
tooltip_df
}
#' Build the plotly choropleth object (without rendering)
#' @param md map data
build_map_plot <- function(md) {
if (!"ComboIndicators" %in% names(md)) stop("Missing ComboIndicators column")
# Early exit if no rows
if (nrow(md) == 0) {
return(
plotly_empty(type = 'choropleth') %>%
layout(
geo = list(scope = 'usa', projection = list(type = 'albers usa')),
showlegend = FALSE
)
)
}
combos <- levels(md$ComboIndicators)
if (is.null(combos)) combos <- sort(unique(md$ComboIndicators))
# Normalize again defensively
combos <- unique(gsub("\\s+", " ", trimws(combos)))
# Define palette: gray for 'None', distinct for others
non_none <- setdiff(combos, "None")
k <- length(non_none)
color_vec <- if (k > 0) {
base_cols <- if (k <= 12) RColorBrewer::brewer.pal(max(3, min(12, k)), 'Set3')[seq_len(k)] else grDevices::rainbow(k)
c('None' = '#f0f0f0', stats::setNames(base_cols, non_none))
} else {
c('None' = '#f0f0f0')
}
# Preserve ordering in legend
color_vec <- color_vec[unique(c('None', setdiff(combos, 'None')))]
p <- plot_ly()
# Static (no frame) traces for legend (single year snapshot)
if (nrow(md) > 0) {
base_year <- suppressWarnings(min(md$Year, na.rm = TRUE))
base_md <- md[md$Year == base_year, , drop = FALSE]
for (combo in combos) {
dfc <- base_md[base_md$ComboIndicators == combo, , drop = FALSE]
if (nrow(dfc) == 0) next
col <- if (!is.null(color_vec[combo])) color_vec[combo] else '#cccccc'
cs <- list(list(0, col), list(1, col))
p <- add_trace(
p,
data = dfc,
type = 'choropleth',
locations = ~locations,
locationmode = 'USA-states',
z = I(rep(1, nrow(dfc))),
zmin = 0, zmax = 1,
colorscale = cs,
showscale = FALSE,
text = ~tooltip,
hoverinfo = 'text',
name = combo,
legendgroup = combo,
showlegend = TRUE,
marker = list(line = list(color = 'white', width = 0.5)),
hoverlabel = list(align = 'left')
)
}
# Animated traces (one per combo including all years) with legend hidden
multi_year <- length(unique(md$Year)) > 1
if (multi_year) {
for (combo in combos) {
dfc_all <- md[md$ComboIndicators == combo, , drop = FALSE]
if (nrow(dfc_all) == 0) next
col <- if (!is.null(color_vec[combo])) color_vec[combo] else '#cccccc'
cs <- list(list(0, col), list(1, col))
p <- add_trace(
p,
data = dfc_all,
type = 'choropleth',
locations = ~locations,
locationmode = 'USA-states',
frame = ~Year,
z = I(rep(1, nrow(dfc_all))),
zmin = 0, zmax = 1,
colorscale = cs,
showscale = FALSE,
text = ~tooltip,
hoverinfo = 'text',
name = combo,
legendgroup = combo,
showlegend = FALSE,
marker = list(line = list(color = 'white', width = 0.5)),
hoverlabel = list(align = 'left')
)
}
}
}
p <- p %>%
layout(
geo = list(scope = 'usa', projection = list(type = 'albers usa'), showland = TRUE,
landcolor = toRGB('gray95'), subunitcolor = toRGB('gray85'), countrycolor = toRGB('gray85'),
lakecolor = toRGB('white'), showsubunits = TRUE, showcountries = TRUE),
margin = list(l = 0, r = 0, t = 0, b = 0),
showlegend = TRUE
)
# Only add animation controls if any trace has a frame (multi-year)
has_frames <- any(vapply(p$x$data, function(tr) !is.null(tr$frame), logical(1)))
if (has_frames) {
p <- p %>%
animation_opts(frame = 800, transition = 200, easing = 'linear', redraw = FALSE) %>%
animation_slider(currentvalue = list(prefix = 'Year: '))
}
p
}
#' Convenience function: build map directly from data + inputs
#' @param data raw data
#' @param inputs list with topic_select, indicator_select
#' @return plotly object
build_map_from_inputs <- function(data, inputs) {
md <- map_data_fn(data, inputs)
build_map_plot(md)
}
build_map_from_inputs(data, inputs)
#' Convenience function: build map directly from data + inputs
#' @param data raw data
#' @param inputs list with topic_select, indicator_select
#' @return plotly object
build_map_from_inputs <- function(data, inputs) {
md <- map_data_fn(data, inputs)
build_map_plot(md)
}
filtered_data_fn <- function(data, inputs) {
if (!all(c("Topic","Indicator") %in% names(data))) return(safe_empty())
if (is.null(inputs$topic_select) || inputs$topic_select == "") return(safe_empty())
if (is.null(inputs$indicator_select) || length(inputs$indicator_select) == 0) return(safe_empty())
out <- data %>%
dplyr::filter(Topic == inputs$topic_select, Indicator %in% inputs$indicator_select)
if (nrow(out) == 0) return(safe_empty())
out
}
#' Detailed summary by Indicator for tooltip
citation_detail_fn <- function(df) {
if (nrow(df) == 0) return(
tibble::tibble(
State=character(),
Year=integer(),
Indicator=character(),
CitationText=character(),
CountIndicator=integer()
)
)
df %>%
dplyr::group_by(State, Year, Indicator) %>%
dplyr::summarise(
CitationText = paste(
unique(
`Statutory or Regulatory Citation Sections`),
collapse = "; "
),
.groups = "drop"
) %>%
dplyr::mutate(
CountIndicator = ifelse(CitationText == "" | is.na(CitationText), 0L, stringr::str_count(CitationText, ";") + 1L)
)
}
#' Build map data (includes combination columns, tooltip, codes)
#' @param data raw data
#' @param inputs list of selections
map_data_fn <- function(data, inputs) {
df_filt <- filtered_data_fn(data, inputs)
detail <- citation_detail_fn(df_filt)
state_ref <- tibble::tibble(State = state.name, locations = state.abb)
year_vec <- if ("Year" %in% names(data) && any(!is.na(data$Year))) {
seq.int(min(data$Year, na.rm = TRUE), max(data$Year, na.rm = TRUE))
} else { 2000:2020 }
full_grid <- tidyr::expand_grid(State = state_ref$State, Year = year_vec)
counts <- detail %>%
dplyr::group_by(State, Year) %>%
dplyr::summarise(Count = sum(CountIndicator), .groups = "drop")
lines <- detail %>%
dplyr::mutate(line = paste0(
"<b>",
htmltools::htmlEscape(Indicator),
"</b><br>",
htmltools::htmlEscape(CitationText)
)
) %>%
dplyr::group_by(State, Year) %>%
dplyr::summarise(lines = paste(line, collapse = "<br>"), .groups = "drop")
combos <- detail %>%
dplyr::group_by(State, Year) %>%
dplyr::summarise(
ComboIndicators = paste(sort(unique(Indicator)), collapse = " + "),
.groups = "drop"
)
tooltip_df <- full_grid %>%
dplyr::left_join(counts, by = c("State","Year")) %>%
dplyr::left_join(lines, by = c("State","Year")) %>%
dplyr::left_join(combos, by = c("State","Year")) %>%
dplyr::left_join(state_ref, by = "State") %>%
dplyr::mutate(
Count = dplyr::coalesce(Count, 0L),
ComboIndicators = dplyr::coalesce(ComboIndicators, "None"),
ComboIndicators = gsub("\\s+", " ", trimws(ComboIndicators)),
HasCitation = as.integer(Count > 0L),
tooltip = ifelse(is.na(lines) | lines == "",
paste0(State, " - ", Year, "<br><i>No citations</i>"),
paste0(State, " - ", Year, "<br>", lines))
)
combo_levels <- sort(unique(tooltip_df$ComboIndicators))
combo_levels <- c(setdiff("None", combo_levels), setdiff(combo_levels, "None"))
tooltip_df <- tooltip_df %>%
dplyr::mutate(
ComboIndicators = factor(ComboIndicators, levels = combo_levels),
ComboCode = as.integer(ComboIndicators) - 1L) %>%
dplyr::filter(!is.na(locations))
tooltip_df
}
#' Build the plotly choropleth object (without rendering)
#' @param md map data
build_map_plot <- function(md) {
if (!"ComboIndicators" %in% names(md)) stop("Missing ComboIndicators column")
# Early exit if no rows
if (nrow(md) == 0) {
return(
plotly_empty(type = 'choropleth') %>%
layout(
geo = list(scope = 'usa', projection = list(type = 'albers usa')),
showlegend = FALSE
)
)
}
combos <- levels(md$ComboIndicators)
if (is.null(combos)) combos <- sort(unique(md$ComboIndicators))
combos <- unique(gsub("\\s+", " ", trimws(combos)))
# Build numeric codes (ensure sequential)
md$ComboIndicators <- factor(md$ComboIndicators, levels = combos)
md$ComboCode <- as.integer(md$ComboIndicators) - 1L
max_code <- ifelse(length(combos) > 0, length(combos) - 1L, 0L)
# Palette
non_none <- setdiff(combos, 'None')
k <- length(non_none)
non_none_cols <- if (k > 0) {
if (k <= 12) RColorBrewer::brewer.pal(max(3, min(12, k)), 'Set3')[seq_len(k)] else grDevices::rainbow(k)
} else character()
palette <- c(if ('None' %in% combos) '#f0f0f0' else NULL, non_none_cols)
names(palette) <- combos
# Discrete stepped colorscale
if (max_code == 0) {
colorscale <- list(list(0, palette[1]), list(1, palette[1]))
} else {
colorscale <- list()
for (i in 0:max_code) {
col <- palette[i + 1]
center <- i / max_code
half <- 0.5 / max_code
start <- max(0, center - half)
end <- min(1, center + half)
colorscale <- append(colorscale, list(list(start, col), list(end, col)))
}
}
multi_year <- length(unique(md$Year)) > 1
p <- plot_ly(
data = md,
type = 'choropleth',
locations = ~locations,
locationmode = 'USA-states',
frame = if (multi_year) ~Year else NULL,
z = ~ComboCode,
zmin = 0, zmax = max_code,
colorscale = colorscale,
showscale = TRUE,
text = ~tooltip,
hoverinfo = 'text',
marker = list(line = list(color = 'white', width = 0.5)),
hoverlabel = list(align = 'left'),
colorbar = list(
title = 'Indicator Combo',
tickmode = 'array',
tickvals = 0:max_code,
ticktext = combos
)
) %>%
layout(
geo = list(scope = 'usa', projection = list(type = 'albers usa'), showland = TRUE,
landcolor = toRGB('gray95'), subunitcolor = toRGB('gray85'), countrycolor = toRGB('gray85'),
lakecolor = toRGB('white'), showsubunits = TRUE, showcountries = TRUE),
margin = list(l = 0, r = 0, t = 0, b = 0),
showlegend = FALSE
)
if (multi_year) {
p <- p %>%
animation_opts(frame = 800, transition = 200, easing = 'linear', redraw = FALSE) %>%
animation_slider(currentvalue = list(prefix = 'Year: '))
}
p
}
#' Convenience function: build map directly from data + inputs
#' @param data raw data
#' @param inputs list with topic_select, indicator_select
#' @return plotly object
build_map_from_inputs <- function(data, inputs) {
md <- map_data_fn(data, inputs)
build_map_plot(md)
}
build_map_from_inputs(data, inputs)
shiny::runApp()
install.packages("maps")
runApp()
runApp()
colnames(data)
setwd('C:/Users/rdefa/OneDrive/Desktop/R_EDA_Dashboards/alysee_app')
data <- readxl::read_excel('sampled_df.xlsx') %>%
add_row()
colnames(data)
unique(data$Topic)
unique(data$Indicators)
unique(data$Indicator)
runApp()
data <- readxl::read_excel('sampled_df.xlsx') %>%
add_row(State = "Washington", Year = 2018, Topic = "Pharmacists", Indicator = "Policy defines CHW", `Statutory or Regulatory Citation Sections` = "Policy A") %>%
add_row(State = "Washington", Year = 2018, Topic = "Pharmacists", Indicator = "Policy defines CHW", `Statutory or Regulatory Citation Sections` = "Policy B") %>%
add_row(State = "Washington", Year = 2018, Topic = "Pharmacists", Indicator = "Digital literacy", `Statutory or Regulatory Citation Sections` = "Policy C")
tail(data)
runApp()
runApp()
inputs <- list(
#  "Community Health Worker(CHW) Policies", "Telehealth Policies", "Pharmacists"
topic_select = "Community Health Worker(CHW) Policies",
indicator_select = c("CHW Roles, Responsibilities or Functions Defined", "Terms used to describe CHW")
)
inputs
#' Filter data based on inputs
#' @param data raw data
#' @param inputs list with topic_select, indicator_select
filtered_data_fn <- function(data, inputs) {
if (!all(c("Topic","Indicator") %in% names(data))) return(safe_empty())
if (is.null(inputs$topic_select) || inputs$topic_select == "") return(safe_empty())
if (is.null(inputs$indicator_select) || length(inputs$indicator_select) == 0) return(safe_empty())
out <- data %>%
dplyr::filter(Topic == inputs$topic_select, Indicator %in% inputs$indicator_select)
if (nrow(out) == 0) return(safe_empty())
out
}
filtered_data_fn(data, inputs)
runApp()
runApp()
runApp()
library(rsconnect)
shiny::runApp('C:/Users/rdefa/OneDrive/Desktop/R_EDA_Dashboards/old_faithful_app/old-faithful-app')
getwd()
setwd('../old-faithful')
getwd()
rsconnect::deployApp(
appName = "old-faithful", # URL-friendly name
appTitle = "Old Faithful App", # Display name
account = "rdefaccio@gmail.com"
)
rsconnect::deployApp(
appName = "old-faithful", # URL-friendly name
appTitle = "Old Faithful App", # Display name
account = "rdefaccio"
)
rsconnect::deployApp(
appName = "old-faithful", # URL-friendly name
appTitle = "Old Faithful App", # Display name
account = "Rian DeFaccio"
)
rsconnect::deployApp(
appName = "old-faithful", # URL-friendly name
appTitle = "Old Faithful App", # Display name
account = "qik1sk-rian-defaccio"
)
getwd()
setwd('../old-faithful-final')
getwd()
